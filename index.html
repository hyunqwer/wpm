<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reading Fluency Analyzer (OpenAI STT)</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; line-height: 1.6; }
    textarea { width: 100%; height: 100px; }
    .word.correct { color: green; font-weight: bold; }
    .word.incorrect { color: red; font-weight: bold; }
    .results { margin-top: 20px; }
  </style>
</head>
<body>
  <h1>Reading Fluency Analyzer (OpenAI STT)</h1>

  <label for="levelSelect">📚 CEFR 수준을 선택하세요:</label>
  <select id="levelSelect">
    <option value="A1">A1 (초급)</option><option value="A2">A2</option>
    <option value="B1">B1</option><option value="B2">B2</option>
    <option value="C1">C1</option><option value="C2">C2 (고급)</option>
  </select><br><br>

  <label for="textInput">📝 읽을 텍스트:</label>
  <textarea id="textInput"></textarea>

  <div>
    <button id="startBtn">Start Reading</button>
    <button id="stopBtn" disabled>Stop Reading</button>
  </div>

  <div class="results">
    <h2>📣 음성 인식 결과:</h2>
    <div id="outputText"></div>
    <h3>📊 분석 결과</h3>
    <p>읽은 시간: <span id="duration"></span>초</p>
    <p>WPM: <span id="wpm"></span></p>
    <p>WCPM: <span id="wcpm"></span></p>
  </div>

  <script>
    /* ---------- 1. 기본 텍스트 세팅 ---------- */
    const texts = {
      A1:"This is a cat. The cat is black!",
      A2:"Anna goes to school every day. She walks with her friend and they talk a lot.",
      B1:"The museum was very interesting. I learned many things about ancient history and art.",
      B2:"Although the weather was bad, we decided to go hiking because we had prepared everything.",
      C1:"The documentary explores the ethical implications of artificial intelligence in modern society.",
      C2:"Contrary to popular belief, economic stagnation can occur even amid technological advancements due to complex sociopolitical factors."
    };
    const $ = id => document.getElementById(id);
    $("levelSelect").onchange = e => $("textInput").value = texts[e.target.value];
    $("textInput").value = texts["A1"];

    /* ---------- 2. 녹음 관련 전역 ---------- */
    let mediaRecorder, audioChunks = [], startTime, endTime;
    const startBtn=$("startBtn"), stopBtn=$("stopBtn"),
          output=$("outputText"), wpm=$("wpm"), wcpm=$("wcpm"), duration=$("duration");

    /* ---------- 3. 지원 mimeType 탐색 ---------- */
    function getSupportedMimeType() {
      const preferred = [
        'audio/mp4',                // iOS Safari 14+ (AAC)
        'audio/webm;codecs=opus',   // 대부분의 크롬·안드로이드
        'audio/webm',
        'audio/mpeg'                // mp3
      ];
      return preferred.find(t => MediaRecorder.isTypeSupported(t)) || '';
    }

    /* ---------- 4. 녹음 시작 ---------- */
    startBtn.onclick = async () => {
      try {
        const mimeType = getSupportedMimeType();
        if (!mimeType) throw new Error("이 브라우저는 MediaRecorder를 지원하지 않습니다.");

        const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
        mediaRecorder = new MediaRecorder(stream, { mimeType });
        audioChunks = [];
        mediaRecorder.ondataavailable = e => e.data.size && audioChunks.push(e.data);

        startTime = Date.now();
        output.innerHTML = "🎤 음성 녹음 중...";
        startBtn.disabled = true;
        stopBtn.disabled  = false;
        mediaRecorder.start();
      } catch(err) {
        alert("마이크 접근 실패: " + err.message);
      }
    };

    /* ---------- 5. 녹음 중지 ---------- */
    stopBtn.onclick = () => {
      stopBtn.disabled = true;
      endTime = Date.now();
      mediaRecorder.stop();

      mediaRecorder.onstop = async () => {
        const mimeType = mediaRecorder.mimeType;
        const ext = mimeType.includes('mp4') ? 'mp4'
                 : mimeType.includes('mpeg')? 'mp3'
                 : 'webm';

        const audioBlob = new Blob(audioChunks, { type: mimeType });
        if (audioBlob.size < 4096) {   // 4KB 미만(≈0.1초) 녹음이면 오류 처리
          alert("녹음된 오디오가 너무 짧거나 비어 있습니다. 다시 시도해 주세요.");
          startBtn.disabled=false; return;
        }

        const formData = new FormData();
        formData.append("file", audioBlob, `audio.${ext}`);
        formData.append("model","whisper-1");

        output.innerHTML = "🧠 음성 인식 중(OpenAI)...";

        try {
          const res = await fetch("https://frosty-term-f13a.hyunqwer.workers.dev/",{
            method:"POST", body:formData });
          if (!res.ok) throw new Error("STT 서버 응답 오류: "+res.status);
          const json = await res.json();
          const transcript = json?.text?.trim();
          if (!transcript) throw new Error("STT 응답에 텍스트가 없습니다.");

          analyzeResults(transcript);
        } catch(err) {
          alert("STT 오류 발생: " + err.message);
        }
        startBtn.disabled=false;
      };
    };

    /* ---------- 6. 결과 분석 ---------- */
    function analyzeResults(transcript){
      const origin   = $("textInput").value.trim().split(/\s+/);
      const spoken   = transcript.split(/\s+/);
      const clean = w => w.toLowerCase().replace(/[.,!?—-]/g,"");
      const lowerO = origin.map(clean), lowerS = spoken.map(clean);

      const matched = new Set(), usedS=new Set();
      lowerO.forEach((w,i)=>{
        const j = lowerS.findIndex((s,idx)=>!usedS.has(idx)&&s===w);
        if (j>-1){ matched.add(i); usedS.add(j); }
      });

      output.innerHTML = origin.map((w,i)=>
        `<span class="word ${matched.has(i)?"correct":"incorrect"}">${w}</span>`).join(" ");

      const sec=(endTime-startTime)/1000;
      duration.textContent = sec.toFixed(1);
      wpm.textContent  = ((spoken.length   /sec)*60).toFixed(1);
      wcpm.textContent = ((matched.size/sec)*60).toFixed(1);
    }
  </script>
</body>
</html>
