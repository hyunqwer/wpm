<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reading Fluency Analyzer (OpenAI STT)</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; line-height: 1.6; }
    textarea { width: 100%; height: 100px; }
    .word.correct { color: green; font-weight: bold; }
    .word.incorrect { color: red; font-weight: bold; }
    .results { margin-top: 20px; }
  </style>
</head>
<body>
  <h1>Reading Fluency Analyzer (OpenAI STT)</h1>

  <label for="levelSelect">ğŸ“š CEFR ìˆ˜ì¤€ì„ ì„ íƒí•˜ì„¸ìš”:</label>
  <select id="levelSelect">
    <option value="A1">A1 (ì´ˆê¸‰)</option><option value="A2">A2</option>
    <option value="B1">B1</option><option value="B2">B2</option>
    <option value="C1">C1</option><option value="C2">C2 (ê³ ê¸‰)</option>
  </select><br><br>

  <label for="textInput">ğŸ“ ì½ì„ í…ìŠ¤íŠ¸:</label>
  <textarea id="textInput"></textarea>

  <div>
    <button id="startBtn">Start Reading</button>
    <button id="stopBtn" disabled>Stop Reading</button>
  </div>

  <div class="results">
    <h2>ğŸ“£ ìŒì„± ì¸ì‹ ê²°ê³¼:</h2>
    <div id="outputText"></div>
    <h3>ğŸ“Š ë¶„ì„ ê²°ê³¼</h3>
    <p>ì½ì€ ì‹œê°„: <span id="duration"></span>ì´ˆ</p>
    <p>WPM: <span id="wpm"></span></p>
    <p>WCPM: <span id="wcpm"></span></p>
  </div>

  <script>
    /* ---------- 1. ê¸°ë³¸ í…ìŠ¤íŠ¸ ì„¸íŒ… ---------- */
    const texts = {
      A1:"This is a cat. The cat is black!",
      A2:"Anna goes to school every day. She walks with her friend and they talk a lot.",
      B1:"The museum was very interesting. I learned many things about ancient history and art.",
      B2:"Although the weather was bad, we decided to go hiking because we had prepared everything.",
      C1:"The documentary explores the ethical implications of artificial intelligence in modern society.",
      C2:"Contrary to popular belief, economic stagnation can occur even amid technological advancements due to complex sociopolitical factors."
    };
    const $ = id => document.getElementById(id);
    $("levelSelect").onchange = e => $("textInput").value = texts[e.target.value];
    $("textInput").value = texts["A1"];

    /* ---------- 2. ë…¹ìŒ ê´€ë ¨ ì „ì—­ ---------- */
    let mediaRecorder, audioChunks = [], startTime, endTime;
    const startBtn=$("startBtn"), stopBtn=$("stopBtn"),
          output=$("outputText"), wpm=$("wpm"), wcpm=$("wcpm"), duration=$("duration");

    /* ---------- 3. ì§€ì› mimeType íƒìƒ‰ ---------- */
    function getSupportedMimeType() {
      const preferred = [
        'audio/mp4',                // iOS Safari 14+ (AAC)
        'audio/webm;codecs=opus',   // ëŒ€ë¶€ë¶„ì˜ í¬ë¡¬Â·ì•ˆë“œë¡œì´ë“œ
        'audio/webm',
        'audio/mpeg'                // mp3
      ];
      return preferred.find(t => MediaRecorder.isTypeSupported(t)) || '';
    }

    /* ---------- 4. ë…¹ìŒ ì‹œì‘ ---------- */
    startBtn.onclick = async () => {
      try {
        const mimeType = getSupportedMimeType();
        if (!mimeType) throw new Error("ì´ ë¸Œë¼ìš°ì €ëŠ” MediaRecorderë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");

        const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
        mediaRecorder = new MediaRecorder(stream, { mimeType });
        audioChunks = [];
        mediaRecorder.ondataavailable = e => e.data.size && audioChunks.push(e.data);

        startTime = Date.now();
        output.innerHTML = "ğŸ¤ ìŒì„± ë…¹ìŒ ì¤‘...";
        startBtn.disabled = true;
        stopBtn.disabled  = false;
        mediaRecorder.start();
      } catch(err) {
        alert("ë§ˆì´í¬ ì ‘ê·¼ ì‹¤íŒ¨: " + err.message);
      }
    };

    /* ---------- 5. ë…¹ìŒ ì¤‘ì§€ ---------- */
    stopBtn.onclick = () => {
      stopBtn.disabled = true;
      endTime = Date.now();
      mediaRecorder.stop();

      mediaRecorder.onstop = async () => {
        const mimeType = mediaRecorder.mimeType;
        const ext = mimeType.includes('mp4') ? 'mp4'
                 : mimeType.includes('mpeg')? 'mp3'
                 : 'webm';

        const audioBlob = new Blob(audioChunks, { type: mimeType });
        if (audioBlob.size < 4096) {   // 4KB ë¯¸ë§Œ(â‰ˆ0.1ì´ˆ) ë…¹ìŒì´ë©´ ì˜¤ë¥˜ ì²˜ë¦¬
          alert("ë…¹ìŒëœ ì˜¤ë””ì˜¤ê°€ ë„ˆë¬´ ì§§ê±°ë‚˜ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.");
          startBtn.disabled=false; return;
        }

        const formData = new FormData();
        formData.append("file", audioBlob, `audio.${ext}`);
        formData.append("model","whisper-1");

        output.innerHTML = "ğŸ§  ìŒì„± ì¸ì‹ ì¤‘(OpenAI)...";

        try {
          const res = await fetch("https://frosty-term-f13a.hyunqwer.workers.dev/",{
            method:"POST", body:formData });
          if (!res.ok) throw new Error("STT ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜: "+res.status);
          const json = await res.json();
          const transcript = json?.text?.trim();
          if (!transcript) throw new Error("STT ì‘ë‹µì— í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.");

          analyzeResults(transcript);
        } catch(err) {
          alert("STT ì˜¤ë¥˜ ë°œìƒ: " + err.message);
        }
        startBtn.disabled=false;
      };
    };

    /* ---------- 6. ê²°ê³¼ ë¶„ì„ ---------- */
    function analyzeResults(transcript){
      const origin   = $("textInput").value.trim().split(/\s+/);
      const spoken   = transcript.split(/\s+/);
      const clean = w => w.toLowerCase().replace(/[.,!?â€”-]/g,"");
      const lowerO = origin.map(clean), lowerS = spoken.map(clean);

      const matched = new Set(), usedS=new Set();
      lowerO.forEach((w,i)=>{
        const j = lowerS.findIndex((s,idx)=>!usedS.has(idx)&&s===w);
        if (j>-1){ matched.add(i); usedS.add(j); }
      });

      output.innerHTML = origin.map((w,i)=>
        `<span class="word ${matched.has(i)?"correct":"incorrect"}">${w}</span>`).join(" ");

      const sec=(endTime-startTime)/1000;
      duration.textContent = sec.toFixed(1);
      wpm.textContent  = ((spoken.length   /sec)*60).toFixed(1);
      wcpm.textContent = ((matched.size/sec)*60).toFixed(1);
    }
  </script>
</body>
</html>
